<!doctype html>
<html lang="zh-Hant-TW">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Kinetic Stills Lab — CapCut Flow v2.0.1</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#111723cc; --card:#0f1621cc; --text:#e8f0ff; --muted:#a9b1c1;
    --accent:#18ffff; --accent2:#ff3cac; --ok:#20d6a8; --danger:#ff4d4f; --radius:14px;
    --shadow:0 10px 30px rgba(0,0,0,.4), inset 0 0 0 1px rgba(255,255,255,.04);
    --line:#253246; --chip:#0b1220; --timeline:#0d1420; --tick:#325077;
  }
  body.theme-light{
    --bg:#f3f6fb; --panel:#ffffffcc; --card:#f7faffcc; --text:#151b26; --muted:#6a778b;
    --accent:#007bff; --accent2:#ff3cac; --ok:#14b8a6; --danger:#ef4444;
    --line:#e3e9f3; --chip:#eef3fb; --timeline:#eef3fb; --tick:#a9b7cf;
  }
  *{box-sizing:border-box} html,body{height:100%}
  body{
    margin:0; font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI","Noto Sans TC","PingFang TC","Microsoft JhengHei",Roboto,Arial,sans-serif;
    background:
      radial-gradient(1200px 1200px at 80% -10%, rgba(255,60,172,.20), transparent 60%),
      radial-gradient(1000px 1000px at 10% 10%, rgba(24,255,255,.14), transparent 60%),
      linear-gradient(180deg, var(--bg), var(--bg));
    color:var(--text); overflow:hidden;
  }
  #app{
    height:100%; display:grid; gap:12px; padding:12px;
    grid-template-rows: 64px minmax(300px,1fr) 220px;
    grid-template-columns: 300px 1fr 380px;
    grid-template-areas:
      "top top top"
      "left center right"
      "left timeline right";
  }
  header{
    grid-area:top; display:flex; align-items:center; justify-content:space-between;
    padding:10px 16px; border-radius:var(--radius);
    background:linear-gradient( to right, var(--card), var(--panel) );
    box-shadow:var(--shadow); backdrop-filter: blur(10px);
  }
  .brand{display:flex; align-items:center; gap:12px; font-weight:700}
  .logo{width:28px;height:28px;border-radius:8px;background:
    conic-gradient(from 180deg, var(--accent), var(--accent2), var(--accent));
    box-shadow:0 0 20px rgba(24,255,255,.35), 0 0 24px rgba(255,60,172,.20) inset;}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .btn{appearance:none;border:0;border-radius:10px;padding:9px 12px;background:linear-gradient(180deg,#182233,#0f1621);
       color:#fff; box-shadow:var(--shadow); cursor:pointer; transition:transform .06s,filter .2s; font-weight:600; letter-spacing:.2px;}
  body.theme-light .btn{ background:linear-gradient(180deg,#2d6bc6,#1e55a8) }
  .btn:hover{filter:brightness(1.07)} .btn:active{transform:translateY(1px) scale(.99)}
  .btn.ghost{ background:transparent; border:1px solid var(--line); color:var(--text)}
  .btn.prim{ border:1px solid rgba(24,255,255,.2)}
  .btn.small{padding:6px 8px; font-size:12px; border-radius:8px}
  .chip{ display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; background:var(--chip); border:1px solid var(--line); color:var(--text); font-size:12px}
  .panel{ background:var(--panel); border-radius:var(--radius); box-shadow:var(--shadow); padding:12px; backdrop-filter:blur(8px); overflow:auto;}
  #library{ grid-area:left}
  #workspace{ grid-area:center; display:flex; flex-direction:column; gap:10px}
  #inspector{ grid-area:right}
  #timeline{ grid-area:timeline; background:var(--panel); border-radius:var(--radius); box-shadow:var(--shadow); padding:8px; overflow:hidden; display:flex; flex-direction:column; gap:6px}
  .field{ display:flex; flex-direction:column; gap:6px; min-width:140px}
  .field label{ color:var(--muted); font-size:12px}
  .field input[type="text"], .field input[type="number"], .field select, .field textarea{
    width:100%; background:#0a0f17; color:#e7f0ff; border:1px solid #1b2736; border-radius:8px; padding:8px 10px; outline:none;
  }
  body.theme-light .field input[type="text"], body.theme-light .field input[type="number"], body.theme-light .field select, body.theme-light .field textarea{
    background:#fff; color:#1a2230; border:1px solid #dbe3ef;
  }
  .thumb{ width:100%; aspect-ratio:16/9; border-radius:10px; background:#0b0f14 center/cover no-repeat; border:1px solid #1b2736}
  body.theme-light .thumb{ background:#f4f7fc; border-color:#dbe3ef}
  .asset{ display:grid; grid-template-columns: 82px 1fr auto; gap:8px; align-items:center; padding:6px; border-radius:10px; background:var(--card); border:1px solid var(--line); margin-bottom:8px}
  .asset .name{ font-size:13px; font-weight:600}
  .asset .meta{ color:var(--muted); font-size:12px}
  .asset .acts{ display:flex; gap:6px}
  .asset[draggable="true"]{ cursor:grab }

  .topbar{ display:flex; align-items:center; justify-content:space-between}
  .seg{ display:inline-flex; background:var(--card); border:1px solid var(--line); border-radius:999px; padding:4px}
  .seg button{ border:0; background:transparent; padding:6px 10px; border-radius:999px; cursor:pointer; color:var(--text)}
  .seg button.active{ background:linear-gradient(180deg,#1b3b52,#112737); color:#fff }
  body.theme-light .seg button.active{ background:linear-gradient(180deg,#2d6bc6,#1e55a8) }

  #previewWrap{ position:relative; display:grid; grid-template-columns:1fr; grid-template-rows:1fr; min-height:320px; gap:10px }
  #previewCanvas{ width:100%; aspect-ratio:16/9; border-radius:12px; background:#000; box-shadow:var(--shadow); cursor:grab }
  #previewCanvas.dragging{ cursor:grabbing }
  .tri{ display:none; grid-template-columns: repeat(3, 1fr); gap:10px}
  .tri canvas{ width:100%; border-radius:10px; background:#000; box-shadow:var(--shadow); aspect-ratio:16/9 }
  .overlayHud{position:absolute; left:8px; top:8px; pointer-events:none; color:#cbd5e7; text-shadow:0 1px 2px #0008; font-size:12px}
  .overlayHudR{position:absolute; right:8px; top:8px; pointer-events:none; color:#cbd5e7; text-shadow:0 1px 2px #0008; font-size:12px}

  .ruler{ height:26px; position:relative; background:var(--timeline); border:1px solid var(--line); border-radius:8px; overflow:hidden}
  #rulerCanvas{ width:100%; height:100%}
  .track{ position:relative; flex:1; background:var(--timeline); border:1px solid var(--line); border-radius:8px; overflow:auto }
  .trackInner{ position:relative; height:100%; min-height:86px }
  .clip{ position:absolute; top:6px; height:60px; background:linear-gradient(180deg, #1b293a, #0f1621); border:1px solid #2d4059; border-radius:8px; box-shadow:var(--shadow); color:#dbe7ff; display:flex; align-items:flex-end; padding:6px; cursor:grab }
  .clip.active{ outline:2px solid var(--accent2) }
  .clip .label{ font-size:12px; line-height:1.3 }
  .clip .handle{ position:absolute; top:0; width:8px; height:100%; cursor:ew-resize; }
  .clip .hL{ left:-4px } .clip .hR{ right:-4px }
  .insertion{ position:absolute; top:0; bottom:0; width:2px; background:var(--accent) }
  .playhead{ position:absolute; top:0; bottom:0; width:2px; background:#fff; pointer-events:none }
  .tlFooter{ display:flex; align-items:center; gap:10px; padding:2px 4px; color:var(--muted) }
  input[type="range"].zoom{ width:220px }

  .keybar{ position:absolute; left:0; right:0; bottom:4px; height:12px; pointer-events:none; }
  .key{ position:absolute; bottom:2px; width:6px; height:8px; border-radius:2px; background:linear-gradient(180deg,#ff3cac,#7a1d52); box-shadow:0 0 8px #ff3cac88}

  .note{ font-size:12px; color:var(--muted)}
  .toggle{ display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; background:var(--chip); border:1px solid var(--line); }
</style>
</head>
<body class="theme-dark">
<div id="app">
  <header>
    <div class="brand"><div class="logo"></div><div>Kinetic Stills Lab <span class="note">— CapCut Flow v2.0.1</span></div></div>
    <div class="row">
      <label class="chip">主題
        <select id="themeSel"><option value="theme-dark" selected>霓虹深色</option><option value="theme-light">霧光淺色</option></select>
      </label>
      <label class="chip">解析度
        <select id="resSel"><option>1280x720</option><option selected>1920x1080</option><option>2560x1440</option><option>3840x2160</option></select>
      </label>
      <button id="playBtn" class="btn prim">播放 <span class="note">Space</span></button>
      <button id="recordBtn" class="btn">錄製 WebM</button>
      <button id="saveBtn" class="btn ghost">匯出專案</button>
      <button id="loadBtn" class="btn ghost">載入專案</button>
      <button id="clearBtn" class="btn" style="background:#4b0f17">清空</button>
    </div>
  </header>

  <!-- 媒體庫 -->
  <aside id="library" class="panel">
    <div class="row"><input id="imgInput" type="file" accept="image/*" multiple class="btn"/></div>
    <div id="assetList" style="margin-top:10px"></div>
  </aside>

  <!-- 工作區 -->
  <section id="workspace" class="panel">
    <div class="topbar">
      <div class="seg">
        <button class="active" data-view="preview" id="viewPreview">整體預覽</button>
        <button data-view="tri" id="viewTri">三視圖</button>
      </div>
      <div class="row">
        <div class="chip">時間 <span id="timeLbl">0.00s</span></div>
        <div class="chip">總長 <span id="totalLbl">0.00s</span></div>
        <label class="chip"><input id="loop" type="checkbox" checked> 循環</label>
        <label class="chip"><input id="showSafe" type="checkbox" checked> 字幕安全區</label>
      </div>
    </div>
    <div id="previewWrap">
      <canvas id="previewCanvas"></canvas>
      <div class="overlayHud" id="hudL"></div>
      <div class="overlayHudR" id="hudR"></div>
      <div class="tri" id="triWrap">
        <canvas id="triA"></canvas>
        <canvas id="triB"></canvas>
        <canvas id="triC"></canvas>
      </div>
    </div>
  </section>

  <!-- Inspector -->
  <aside id="inspector" class="panel">
    <div class="field"><label>OpenAI API Key（示範用；正式請走後端 Proxy）</label><input id="apiKey" type="password" placeholder="sk-..."/></div>
    <div class="row" style="margin-bottom:6px"><button id="rememberKey" class="btn small">記住 Key</button></div>

    <div class="row">
      <div class="field"><label>片段（Clip）資訊</label><div class="note" id="clipInfo">未選取</div></div>
    </div>

    <div class="row"><span class="chip">🎬 運鏡（Shot Planner）</span></div>
    <div class="row">
      <div class="field">
        <label>運鏡手法</label>
        <select id="cineMove">
          <option value="static">靜止</option>
          <option value="truckR">Truck 右</option><option value="truckL">Truck 左</option>
          <option value="pedUp">Pedestal 上</option><option value="pedDown">Pedestal 下</option>
          <option value="panL">Pan 左</option><option value="panR">Pan 右</option>
          <option value="tiltUp">Tilt 上</option><option value="tiltDown">Tilt 下</option>
          <option value="zoomIn">Zoom In（或 Dolly In）</option><option value="zoomOut">Zoom Out（或 Dolly Out）</option>
          <option value="orbitL">Orbit 左</option><option value="orbitR">Orbit 右</option>
        </select>
      </div>
      <div class="field"><label>幅度（%／度，自動依手法）</label><input id="cineAmount" type="number" step="1" value="60"/></div>
    </div>
    <div class="row">
      <div class="field">
        <label>拍攝距離（鏡頭遠近）</label>
        <select id="shotScale">
          <option value="ELS">遠遠景（ELS）</option><option value="LS">遠景（LS）</option>
          <option value="MLS">中遠景（MLS）</option><option value="MS" selected>中景（MS）</option>
          <option value="MCU">中近景（MCU）</option><option value="CU">近景／特寫（CU）</option>
          <option value="XCU">極特寫（XCU）</option>
        </select>
      </div>
      <div class="field">
        <label>拍攝角度（視角／傾斜）</label>
        <select id="shotAngle">
          <option value="eye" selected>平視</option><option value="high">高角度（俯拍）</option><option value="low">低角度（仰拍）</option>
          <option value="top">俯視（Top-down）</option><option value="bottom">仰視（Bottom-up）</option>
          <option value="dutch">荷蘭式（傾斜）</option><option value="oblique">斜側視角</option>
        </select>
      </div>
    </div>
    <div class="row">
      <button id="applyCine" class="btn prim">套用運鏡 → 產生起訖關鍵幀</button>
      <label class="toggle"><input id="limitByMove" type="checkbox" checked> 限制取景：依運鏡手法</label>
      <label class="chip">轉場
        <select id="transitionType"><option value="none">無</option><option value="crossfade" selected>交叉淡入</option><option value="slideL">滑動（左）</option><option value="slideR">滑動（右）</option><option value="zoom">鏡頭推近</option><option value="dipWhite">染白</option><option value="dipBlack">染黑</option></select>
      </label>
      <label class="chip">時長（秒）<input id="transitionDur" type="number" step="0.1" value="0.8" style="width:72px"/></label>
    </div>

    <details style="margin-top:10px">
      <summary>進階數值（仿射／近似透視、濾鏡、特效）</summary>
      <div class="row" style="margin-top:8px">
        <div class="field"><label>平移 X</label><input id="tx" type="number" step="1" value="0"/></div>
        <div class="field"><label>平移 Y</label><input id="ty" type="number" step="1" value="0"/></div>
        <div class="field"><label>縮放</label><input id="scale" type="number" step="0.01" value="1"/></div>
        <div class="field"><label>旋轉（°）</label><input id="rot" type="number" step="0.1" value="0"/></div>
        <div class="field"><label>傾斜 X</label><input id="skx" type="number" step="0.1" value="0"/></div>
        <div class="field"><label>傾斜 Y</label><input id="sky" type="number" step="0.1" value="0"/></div>
        <div class="field"><label>近似透視：旋轉X（°）</label><input id="rotx" type="number" step="0.1" value="0"/></div>
        <div class="field"><label>近似透視：旋轉Y（°）</label><input id="roty" type="number" step="0.1" value="0"/></div>
      </div>
      <div class="row">
        <button id="addKeyBtn" class="btn small">在當前時間加關鍵幀</button>
        <label class="chip"><input id="autoKey" type="checkbox"> 自動關鍵幀</label>
      </div>
      <div class="row">
        <div class="field"><label>亮度</label><input id="bright" type="number" step="0.01" value="1"/></div>
        <div class="field"><label>對比</label><input id="contrast" type="number" step="0.01" value="1"/></div>
        <div class="field"><label>飽和</label><input id="saturate" type="number" step="0.01" value="1"/></div>
        <div class="field"><label>模糊(px)</label><input id="blur" type="number" step="0.5" value="0"/></div>
      </div>
      <div class="row">
        <label class="chip"><input id="shakeEnable" type="checkbox"> 震動</label>
        <label class="chip">震幅(px) <input id="shakeAmp" type="number" step="0.5" value="8" style="width:72px"/></label>
        <label class="chip">頻率(Hz) <input id="shakeFreq" type="number" step="0.1" value="8" style="width:72px"/></label>
        <button id="addStarburst" class="btn small">在此刻觸發星光</button>
      </div>
    </details>

    <div class="hr" style="margin:12px 0; height:1px; background:var(--line)"></div>

    <div><span class="chip">字幕</span></div>
    <div class="row" style="margin-top:6px">
      <input id="srtInput" type="file" accept=".srt" class="btn"/>
      <button id="addSubtitle" class="btn">新增字幕</button>
    </div>
    <div id="subtitleList" style="max-height:200px; overflow:auto; margin-top:6px"></div>

    <div class="hr" style="margin:12px 0; height:1px; background:var(--line)"></div>

    <div><span class="chip">旁白 / 配音（OpenAI TTS）</span></div>
    <div class="row">
      <label class="chip">模型
        <select id="ttsModel"><option value="gpt-4o-mini-tts" selected>gpt-4o-mini-tts</option><option value="tts-1">tts-1</option><option value="tts-1-hd">tts-1-hd</option></select>
      </label>
      <label class="chip">Voice
        <select id="ttsVoice"><option>alloy</option><option>verse</option><option>shimmer</option><option>coral</option><option>ash</option><option>ballad</option><option>echo</option><option>sage</option></select>
      </label>
      <label class="chip">格式
        <select id="ttsFormat"><option>mp3</option><option>wav</option><option>opus</option><option>aac</option></select>
      </label>
    </div>
    <div class="field" style="margin-top:6px"><label>加入時間（秒，留空=目前指針）</label><input id="ttsAt" type="number" step="0.01" placeholder="例如 3.2"/></div>
    <div class="field"><label>旁白文字</label><textarea id="ttsText" placeholder="這一幕，我們從遠端拉近，光斑掠過鏡頭，燃起期待。"></textarea></div>
    <div class="row"><button id="ttsGen" class="btn prim">產生並加入時間軸</button><button id="ttsPreview" class="btn">預聽</button></div>
  </aside>

  <!-- 時間軸 -->
  <section id="timeline">
    <div class="ruler"><canvas id="rulerCanvas"></canvas></div>
    <div class="track" id="track">
      <div class="trackInner" id="trackInner">
        <div class="playhead" id="playhead"></div>
        <div class="keybar" id="keybar"></div>
      </div>
    </div>
    <div class="tlFooter">
      <span class="note">拖曳媒體到時間軸新增片段；拖動片段重新排序；拖左右邊緣改時長；點擊時間軸可移動指針。</span>
      <label class="chip">時間軸縮放 <input type="range" min="0.6" max="3" step="0.1" value="1" class="zoom" id="zoom"/></label>
    </div>
  </section>
</div>

<script>
(() => {
  const $ = s=>document.querySelector(s);
  const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const toRad=d=>d*Math.PI/180;
  const now = ()=>performance.now();

  const state = {
    theme:'theme-dark',
    assets:[],
    scenes:[],
    subtitles:[],
    audioCues:[],
    t:0, playing:false, lastTick:0, loop:true,
    canvasW:1920, canvasH:1080,
    showSafe:true,
    activeIdx:-1,
    autoKey:false,
    apiKey:localStorage.getItem('OPENAI_KEY')||'',
    pxPerSecBase:120, zoom:1.0,
    view:'preview',
    limitByMove:true,
  };

  const canvas=$('#previewCanvas'), ctx=canvas.getContext('2d'); let FPS=30;
  const triA=$('#triA'), triB=$('#triB'), triC=$('#triC');
  const aCtx=triA.getContext('2d'), bCtx=triB.getContext('2d'), cCtx=triC.getContext('2d');

  const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  const masterGain = audioCtx.createGain(); masterGain.gain.value=1.0; masterGain.connect(audioCtx.destination);
  const mediaDest = audioCtx.createMediaStreamDestination(); masterGain.connect(mediaDest);

  const ui = {
    themeSel:$('#themeSel'), resSel:$('#resSel'),
    imgInput:$('#imgInput'), assetList:$('#assetList'),
    viewPreview:$('#viewPreview'), viewTri:$('#viewTri'), triWrap:$('#triWrap'),
    timeLbl:$('#timeLbl'), totalLbl:$('#totalLbl'), loop:$('#loop'), showSafe:$('#showSafe'),
    playBtn:$('#playBtn'), recordBtn:$('#recordBtn'), saveBtn:$('#saveBtn'), loadBtn:$('#loadBtn'), clearBtn:$('#clearBtn'),
    clipInfo:$('#clipInfo'), cineMove:$('#cineMove'), cineAmount:$('#cineAmount'),
    shotScale:$('#shotScale'), shotAngle:$('#shotAngle'), applyCine:$('#applyCine'),
    transitionType:$('#transitionType'), transitionDur:$('#transitionDur'),
    tx:$('#tx'), ty:$('#ty'), scale:$('#scale'), rot:$('#rot'), skx:$('#skx'), sky:$('#sky'), rotx:$('#rotx'), roty:$('#roty'),
    bright:$('#bright'), contrast:$('#contrast'), saturate:$('#saturate'), blur:$('#blur'),
    addKeyBtn:$('#addKeyBtn'), autoKey:$('#autoKey'),
    shakeEnable:$('#shakeEnable'), shakeAmp:$('#shakeAmp'), shakeFreq:$('#shakeFreq'), addStarburst:$('#addStarburst'),
    srtInput:$('#srtInput'), addSubtitle:$('#addSubtitle'), subtitleList:$('#subtitleList'),
    apiKey:$('#apiKey'), rememberKey:$('#rememberKey'),
    ttsModel:$('#ttsModel'), ttsVoice:$('#ttsVoice'), ttsFormat:$('#ttsFormat'), ttsText:$('#ttsText'), ttsGen:$('#ttsGen'), ttsPreview:$('#ttsPreview'), ttsAt:$('#ttsAt'), /* ← 修正 */
    track:$('#track'), trackInner:$('#trackInner'), playhead:$('#playhead'), keybar:$('#keybar'),
    zoom:$('#zoom'), rulerCanvas:$('#rulerCanvas'),
    hudL:$('#hudL'), hudR:$('#hudR'),
    limitByMove:$('#limitByMove'),
  };

  ui.apiKey.value = state.apiKey;

  function resizeCanvas(){
    canvas.width=state.canvasW; canvas.height=state.canvasH;
    triA.width=triB.width=triC.width = 640; triA.height=triB.height=triC.height = Math.round(640*9/16);
    draw();
  }
  resizeCanvas();

  /* 主題/解析度 */
  ui.themeSel.addEventListener('change', ()=>{
    document.body.classList.remove('theme-dark','theme-light');
    document.body.classList.add(ui.themeSel.value); state.theme=ui.themeSel.value;
  });
  ui.resSel.addEventListener('change', ()=>{
    const [w,h]=ui.resSel.value.split('x').map(n=>parseInt(n,10));
    state.canvasW=w; state.canvasH=h; resizeCanvas(); drawRuler();
  });

  /* 媒體庫 */
  ui.imgInput.addEventListener('change', async (e)=>{
    const files=Array.from(e.target.files||[]);
    for(const f of files){
      const url=URL.createObjectURL(f); const img=await loadImage(url);
      state.assets.push({id:crypto.randomUUID(), name:f.name, url, img, w:img.naturalWidth, h:img.naturalHeight});
    }
    renderAssets();
  });
  function loadImage(url){ return new Promise(res=>{ const im=new Image(); im.onload=()=>res(im); im.src=url; }); }
  function renderAssets(){
    ui.assetList.innerHTML='';
    state.assets.forEach(a=>{
      const div=document.createElement('div'); div.className='asset'; div.draggable=true; div.dataset.id=a.id;
      div.addEventListener('dragstart', ev=>{ ev.dataTransfer.setData('text/plain', 'asset:'+a.id); });
      div.addEventListener('dblclick', ()=> addClipAtIndex(a.id, state.scenes.length));
      const th=document.createElement('div'); th.className='thumb'; th.style.backgroundImage=`url(${a.url})`;
      const meta=document.createElement('div'); meta.innerHTML=`<div class="name">${a.name}</div><div class="note">${a.w}×${a.h}</div>`;
      const acts=document.createElement('div'); acts.className='acts';
      const addBtn=document.createElement('button'); addBtn.className='btn small'; addBtn.textContent='加到時間軸'; addBtn.onclick=()=> addClipAtIndex(a.id, state.scenes.length);
      const rmBtn=document.createElement('button'); rmBtn.className='btn small'; rmBtn.textContent='移除'; rmBtn.onclick=()=>{ URL.revokeObjectURL(a.url); state.assets=state.assets.filter(x=>x!==a); renderAssets(); };
      acts.append(addBtn,rmBtn); div.append(th,meta,acts); ui.assetList.append(div);
    });
  }

  /* Clip / Scene */
  function makeDefaultKF(){ return {t:0, tx:0, ty:0, s:1, r:0, skx:0, sky:0, rotx:0, roty:0, filt:{b:1,c:1,s:1,blur:0}}; }
  function makeScene(assetId){ return { id:crypto.randomUUID(), assetId, duration:4, kfs:[makeDefaultKF(), {...makeDefaultKF(), t:4}], fx:{shake:{on:false,amp:8,freq:8}}, trans:{type:'crossfade', dur:.8}, sparks:[] }; }
  function assetById(id){ return state.assets.find(a=>a.id===id); }
  function projectTotal(){ return state.scenes.reduce((acc,s)=>acc+s.duration,0); }
  function addClipAtIndex(assetId, index){ const sc=makeScene(assetId); state.scenes.splice(index,0,sc); state.activeIdx=index; renderTimeline(); refreshTotals(); draw(); }

  /* Timeline */
  const rulerCtx = $('#rulerCanvas').getContext('2d');
  function pxPerSec(){ return state.pxPerSecBase * state.zoom; } function timeToX(t){ return t*pxPerSec(); } function xToTime(x){ return x/pxPerSec(); }
  function refreshTotals(){ const total=projectTotal(); ui.totalLbl.textContent=total.toFixed(2)+'s'; drawRuler(); renderPlayhead(); }
  function renderTimeline(){
    const inner=ui.trackInner; inner.innerHTML=''; inner.append(ui.playhead); inner.append(ui.keybar);
    const total=projectTotal(); inner.style.width = Math.max(inner.clientWidth, timeToX(total)+200) + 'px';
    let acc=0;
    state.scenes.forEach((s,idx)=>{
      const a=assetById(s.assetId);
      const clip=document.createElement('div'); clip.className='clip'; if(idx===state.activeIdx) clip.classList.add('active');
      const left=timeToX(acc), width=timeToX(s.duration); clip.style.left=left+'px'; clip.style.width=width+'px'; clip.dataset.idx=idx;
      const label=document.createElement('div'); label.className='label'; label.innerHTML = `<b>${idx+1}｜${a?.name||'素材'}</b><br/><span class="note">${s.duration.toFixed(2)}s • ${s.trans.type} ${s.trans.dur}s</span>`;
      clip.append(label);
      clip.draggable=true; clip.addEventListener('dragstart', ev=>{ ev.dataTransfer.setData('text/plain', 'clip:'+idx); });
      clip.addEventListener('click', ()=>{ state.activeIdx=idx; updateInspector(); highlightActive(); });
      const hL=document.createElement('div'); hL.className='handle hL'; const hR=document.createElement('div'); hR.className='handle hR';
      hR.addEventListener('mousedown', e=> startResize(e, idx, 'right')); hL.addEventListener('mousedown', e=> startResize(e, idx, 'left'));
      clip.append(hL,hR); inner.append(clip); acc+=s.duration;
    });
    ui.track.addEventListener('dragover', onDragOver); ui.track.addEventListener('dragleave', clearInsertion); ui.track.addEventListener('drop', onDrop);
    renderPlayhead();
  }
  function highlightActive(){ document.querySelectorAll('.clip').forEach((c,i)=> c.classList.toggle('active', i===state.activeIdx)); updateInspector(); }
  let insertionEl=null; function showInsertion(x){ if(!insertionEl){ insertionEl=document.createElement('div'); insertionEl.className='insertion'; ui.trackInner.append(insertionEl);} insertionEl.style.left=x+'px'; }
  function clearInsertion(){ if(insertionEl){ insertionEl.remove(); insertionEl=null; } }
  function onDragOver(ev){ ev.preventDefault(); const rect=ui.trackInner.getBoundingClientRect(); const x=ev.clientX-rect.left + ui.track.scrollLeft; const idx=dropIndexByX(x); showInsertion(boundaryXByIndex(idx)); }
  function onDrop(ev){ ev.preventDefault(); const data=ev.dataTransfer.getData('text/plain')||''; const rect=ui.trackInner.getBoundingClientRect(); const x=ev.clientX-rect.left + ui.track.scrollLeft; const idx=dropIndexByX(x); clearInsertion();
    if(data.startsWith('asset:')){ addClipAtIndex(data.split(':')[1], idx); }
    else if(data.startsWith('clip:')){ const from=parseInt(data.split(':')[1],10); if(from===idx||from+1===idx) return; const sc=state.scenes.splice(from,1)[0]; const insert=from<idx?idx-1:idx; state.scenes.splice(insert,0,sc); state.activeIdx=insert; renderTimeline(); refreshTotals(); draw(); }
  }
  function dropIndexByX(x){ let acc=0; for(let i=0;i<state.scenes.length;i++){ const left=timeToX(acc); const right=left+timeToX(state.scenes[i].duration); if(x<=left) return i; if(x>left&&x<=right) return i+1; acc+=state.scenes[i].duration; } return state.scenes.length; }
  function boundaryXByIndex(i){ let acc=0; for(let k=0;k<i;k++) acc+=state.scenes[k].duration; return timeToX(acc); }
  let resizing=null; function startResize(e,idx,side){ e.stopPropagation(); resizing={ idx,side,startX:e.clientX,origDur:state.scenes[idx].duration }; document.addEventListener('mousemove',onResizing); document.addEventListener('mouseup',endResize); }
  function onResizing(e){ if(!resizing) return; const dx=e.clientX-resizing.startX; const dt=dx/pxPerSec(); const step=.1; let dur= resizing.side==='right' ? resizing.origDur+dt : resizing.origDur-dt; dur=clamp(Math.round(dur/step)*step, .2, 1200); state.scenes[resizing.idx].duration=dur; renderTimeline(); refreshTotals(); draw(); }
  function endResize(){ document.removeEventListener('mousemove',onResizing); document.removeEventListener('mouseup',endResize); resizing=null; }
  ui.track.addEventListener('mousedown', e=>{ const rect=ui.trackInner.getBoundingClientRect(); const x=e.clientX-rect.left + ui.track.scrollLeft; state.t=clamp(xToTime(x),0,projectTotal()); ui.timeLbl.textContent=state.t.toFixed(2)+'s'; draw(); renderPlayhead();
    function move(ev){ const x2=ev.clientX-rect.left + ui.track.scrollLeft; state.t=clamp(xToTime(x2),0,projectTotal()); ui.timeLbl.textContent=state.t.toFixed(2)+'s'; draw(); renderPlayhead(); }
    function up(){ document.removeEventListener('mousemove', move); document.removeEventListener('mouseup', up); }
    document.addEventListener('mousemove', move); document.addEventListener('mouseup', up);
  });
  ui.zoom.addEventListener('input', ()=>{ state.zoom=parseFloat(ui.zoom.value)||1; renderTimeline(); drawRuler(); renderPlayhead(); });
  function renderPlayhead(){ ui.playhead.style.left = timeToX(state.t)+'px'; }
  function drawRuler(){ const c=ui.rulerCanvas, w=ui.track.clientWidth; c.width=w; c.height=ui.rulerCanvas.clientHeight||26; const g=rulerCtx; g.clearRect(0,0,c.width,c.height);
    const total=projectTotal(); const scale=pxPerSec(); const major=1, minor=0.5; const maxT=Math.max(total, xToTime(c.width)); g.fillStyle=getComputedStyle(document.body).getPropertyValue('--tick'); g.strokeStyle=g.fillStyle; g.lineWidth=1; g.font='12px system-ui'; g.fillStyle=g.strokeStyle;
    for(let t=0;t<=maxT+0.001;t+=minor){ const x=t*scale+0.5; const isMajor=Math.abs((t/major)-Math.round(t/major))<1e-6; g.beginPath(); g.moveTo(x,c.height); g.lineTo(x,c.height-(isMajor?12:6)); g.stroke(); if(isMajor){ g.fillText(t.toFixed(0)+'s', x+4, 10); } }
  }

  /* 視圖切換 / 播放 */
  ui.viewPreview.addEventListener('click', ()=>{ state.view='preview'; setViewButtons(); });
  ui.viewTri.addEventListener('click', ()=>{ state.view='tri'; setViewButtons(); });
  function setViewButtons(){ ui.viewPreview.classList.toggle('active', state.view==='preview'); ui.viewTri.classList.toggle('active', state.view==='tri'); $('#previewCanvas').style.display = state.view==='preview'?'block':'none'; ui.triWrap.style.display = state.view==='tri'?'grid':'none'; draw(); }
  ui.playBtn.addEventListener('click', togglePlay); document.addEventListener('keydown', e=>{ if(e.code==='Space'){ e.preventDefault(); togglePlay(); } if(e.key.toLowerCase()==='k'){ addKeyAtCurrent(); }});
  ui.loop.addEventListener('change', ()=> state.loop = ui.loop.checked); ui.showSafe.addEventListener('change', ()=> { state.showSafe=ui.showSafe.checked; draw(); });
  function togglePlay(){ state.playing=!state.playing; ui.playBtn.textContent = state.playing? '暫停 ▌▌' : '播放 ▶'; state.lastTick=now(); audioCtx.resume(); if(state.playing) step(); }
  function step(){ if(!state.playing) return; const tnow=now(); const dt=(tnow-state.lastTick)/1000; state.lastTick=tnow; state.t += dt; const total=projectTotal();
    if(state.t>total){ if(state.loop) state.t=0; else { state.t=total; state.playing=false; ui.playBtn.textContent='播放 ▶'; } }
    ui.timeLbl.textContent = state.t.toFixed(2)+'s'; renderPlayhead(); triggerAudioCues(); draw(); requestAnimationFrame(step); }

  /* 取景拖曳／縮放 */
  ui.limitByMove.addEventListener('change', ()=> state.limitByMove = ui.limitByMove.checked);
  let drag={on:false, sx:0, sy:0, startTx:0, startTy:0};
  canvas.addEventListener('mousedown', e=>{
    if(state.view!=='preview') return;
    const sc=state.scenes[state.activeIdx]; if(!sc) return;
    drag.on=true; canvas.classList.add('dragging'); drag.sx=e.clientX; drag.sy=e.clientY;
    const {localT}=timeToScene(state.t); const k=kfAt(sc, localT);
    drag.startTx=k.tx; drag.startTy=k.ty;
    e.preventDefault();
  });
  window.addEventListener('mousemove', e=>{
    if(!drag.on) return;
    const sc=state.scenes[state.activeIdx]; if(!sc) return;
    const {localT}=timeToScene(state.t); const k=kfAt(sc, localT);
    const dx=e.clientX-drag.sx, dy=e.clientY-drag.sy;
    k.tx = drag.startTx + dx; k.ty = drag.startTy + dy;
    clampKFToBounds(k, assetById(sc.assetId), state.limitByMove?ui.cineMove.value:'none');
    applyKFToInspector(k); if(state.autoKey) writeKeyAt(sc, localT, k); draw();
  });
  window.addEventListener('mouseup', ()=>{
    if(!drag.on) return; drag.on=false; canvas.classList.remove('dragging');
    const sc=state.scenes[state.activeIdx]; if(!sc) return; const {localT}=timeToScene(state.t); const k=kfAt(sc, localT); writeKeyAt(sc, localT, k); renderKeybar(sc);
  });
  canvas.addEventListener('wheel', e=>{
    if(state.view!=='preview') return;
    const sc=state.scenes[state.activeIdx]; if(!sc) return;
    const {localT}=timeToScene(state.t); const k=kfAt(sc, localT);
    const factor = Math.exp(-e.deltaY*0.0015);
    k.s = clamp(k.s*factor, 1.0, 6.0); // minCover=1.0；不出黑邊
    clampKFToBounds(k, assetById(sc.assetId), state.limitByMove?ui.cineMove.value:'none');
    applyKFToInspector(k); writeKeyAt(sc, localT, k); draw();
    e.preventDefault();
  }, {passive:false});
  canvas.addEventListener('dblclick', ()=>{
    const sc=state.scenes[state.activeIdx]; if(!sc) return; const {localT}=timeToScene(state.t); const k=kfAt(sc, localT);
    k.tx=0; k.ty=0; clampKFToBounds(k, assetById(sc.assetId), state.limitByMove?ui.cineMove.value:'none');
    applyKFToInspector(k); writeKeyAt(sc, localT, k); draw();
  });
  function applyKFToInspector(k){
    ui.tx.value=k.tx; ui.ty.value=k.ty; ui.scale.value=k.s; ui.rot.value=k.r; ui.skx.value=k.skx; ui.sky.value=k.sky; ui.rotx.value=k.rotx; ui.roty.value=k.roty;
  }
  function writeKeyAt(sc, t, k){
    const eps=1/60;
    let found=sc.kfs.find(x=>Math.abs(x.t - t) < eps);
    if(found) Object.assign(found, JSON.parse(JSON.stringify(k)), {t});
    else sc.kfs.push({...JSON.parse(JSON.stringify(k)), t});
    renderKeybar(sc);
  }

  /* 繪製 */
  function timeToScene(t){
    let acc=0; for(let i=0;i<state.scenes.length;i++){ const s=state.scenes[i];
      if(t < acc + s.duration){
        const localT=t-acc; let prevIdx=i-1, tp=null, tt=null;
        if(prevIdx>=0){ const d=s.trans?.dur||0; if(localT<d && (s.trans?.type||'none')!=='none'){ tp=clamp(localT/d,0,1); tt=s.trans.type; } }
        return {idx:i, localT, prevIdx, transProgress:tp, transType:tt};
      } acc+=s.duration;
    }
    const lastIdx=state.scenes.length-1; return {idx:lastIdx, localT:(state.scenes[lastIdx]?.duration||0), prevIdx:lastIdx-1, transProgress:null, transType:null};
  }
  function kfAt(scene,t){
    const ks = scene.kfs.sort((a,b)=>a.t-b.t);
    if(!ks.length) return makeDefaultKF();
    let a=ks[0], b=ks[ks.length-1];
    for(let i=0;i<ks.length-1;i++){ if(t>=ks[i].t && t<=ks[i+1].t){ a=ks[i]; b=ks[i+1]; break; } }
    const span=Math.max(1e-6, b.t-a.t); const p=clamp((t-a.t)/span,0,1); const I=(u,v)=>lerp(u,v,p);
    return { t, tx:I(a.tx,b.tx), ty:I(a.ty,b.ty), s:I(a.s,b.s), r:I(a.r,b.r), skx:I(a.skx,b.skx), sky:I(a.sky,b.sky), rotx:I(a.rotx,b.rotx), roty:I(a.roty,b.roty), filt:{ b:I(a.filt.b,b.filt.b), c:I(a.filt.c,b.filt.c), s:I(a.filt.s,b.filt.s), blur:I(a.filt.blur,b.filt.blur)} };
  }
  const sparkLive=[];
  function draw(){
    const W=canvas.width,H=canvas.height;
    if(state.view==='preview'){
      ctx.clearRect(0,0,W,H); ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);
      if(!state.scenes.length){ drawBanner(ctx,W,H); return; }
      const info=timeToScene(state.t); const cur=state.scenes[info.idx]; const prev=state.scenes[info.prevIdx];
      if(info.transProgress!=null && prev){ const kPrev=kfAt(prev, prev.duration); drawScene(ctx, prev, kPrev, 1-info.transProgress, {mode:info.transType, p:info.transProgress, back:true}); }
      const kCur=kfAt(cur, info.localT); drawScene(ctx, cur, kCur, 1.0, {mode:info.transType,p:info.transProgress,back:false});
      drawSubtitles(ctx,state.t,W,H);
      if(state.showSafe){ ctx.save(); ctx.strokeStyle='rgba(255,255,255,.15)'; ctx.lineWidth=2; const pad=Math.round(H*0.08); ctx.strokeRect(pad, H - pad*2.5, W - pad*2, pad*1.6); ctx.restore(); }
      ui.hudL.textContent = `拖曳移動、滾輪縮放、雙擊回中心`; ui.hudR.textContent = `${W}×${H}`;
    }else{
      drawTriViews();
    }
  }
  function drawBanner(g,W,H){
    const grad=g.createLinearGradient(0,0,W,0); grad.addColorStop(0,'#18ffff'); grad.addColorStop(1,'#ff3cac');
    g.save(); g.fillStyle=getComputedStyle(document.body).getPropertyValue('--bg'); g.fillRect(0,0,W,H);
    g.font=Math.round(H*0.07)+'px system-ui'; g.textAlign='center'; g.shadowColor='#000'; g.shadowBlur=16; g.fillStyle='#fff';
    g.fillText('把圖片拖到時間軸開始', W/2, H*0.45); g.shadowBlur=0; g.fillStyle=grad; g.font=Math.round(H*0.035)+'px system-ui';
    g.fillText('拖曳取景 + 手法限制，不再只挖角落', W/2, H*0.54); g.restore();
  }
  function drawScene(g, sc, k, alpha=1.0, transInfo){
    const W=g.canvas.width, H=g.canvas.height; const a=assetById(sc.assetId); if(!a?.img) return;
    g.save();
    let shakeX=0, shakeY=0; if(sc.fx.shake.on){ const t=state.t, amp=sc.fx.shake.amp, freq=sc.fx.shake.freq; shakeX=Math.sin(t*freq*2*Math.PI)*amp; shakeY=Math.cos(t*(freq*1.3)*2*Math.PI)*amp*0.7;}
    const arI=a.w/a.h, arC=W/H; let dw,dh; if(arI>arC){ dh=H*k.s; dw=dh*arI; } else { dw=W*k.s; dh=dw/arI; }
    const perspX=Math.cos(toRad(k.rotx)), perspY=Math.cos(toRad(k.roty));
    const cx=W/2 + k.tx + shakeX, cy=H/2 + k.ty + shakeY;
    g.globalAlpha=alpha;
    g.translate(cx,cy); g.rotate(toRad(k.r)); g.transform(1, Math.tan(toRad(k.sky)), Math.tan(toRad(k.skx)), 1, 0, 0); g.scale(perspY, perspX);
    if(transInfo?.p!=null && transInfo.mode && !transInfo.back){ const p=transInfo.p; switch(transInfo.mode){ case 'slideL': g.translate((1-p)*W,0); break; case 'slideR': g.translate(-(1-p)*W,0); break; case 'zoom': g.scale(0.85+0.15*p,0.85+0.15*p); break; case 'dipWhite': hudDip(g,'#fff',(1-p)*0.7); break; case 'dipBlack': hudDip(g,'#000',(1-p)*0.7); break; } }
    if(transInfo?.p!=null && transInfo.mode && transInfo.back){ const p=transInfo.p; switch(transInfo.mode){ case 'slideL': g.translate(-p*W,0); break; case 'slideR': g.translate(p*W,0); break; case 'zoom': g.scale(1.0+0.15*p,1.0+0.15*p); break; } }
    const off=document.createElement('canvas'); off.width=Math.max(1,Math.round(dw)); off.height=Math.max(1,Math.round(dh));
    const o=off.getContext('2d'); o.filter=`blur(${k.filt.blur||0}px) brightness(${k.filt.b||1}) contrast(${k.filt.c||1}) saturate(${k.filt.s||1})`;
    o.drawImage(a.img, 0,0, off.width, off.height);
    g.drawImage(off, -dw/2, -dh/2, dw, dh);
    const { localT } = timeToScene(state.t);
    sc.sparks.forEach(sp=>{ if(Math.abs(localT-sp.t) < (1/FPS)*1.2){ spawnSparks(cx,cy, sp.count||24); }});
    drawSparks(g); g.restore();
  }
  function hudDip(g,color,a){ g.save(); g.setTransform(1,0,0,1,0,0); g.globalAlpha=a; g.fillStyle=color; g.fillRect(0,0,g.canvas.width,g.canvas.height); g.restore(); }
  function spawnSparks(x,y,count){ for(let i=0;i<count;i++){ const A=Math.random()*Math.PI*2; const spd=200+Math.random()*400; sparkLive.push({x,y,vx:Math.cos(A)*spd,vy:Math.sin(A)*spd,life:.6+Math.random()*.6,age:0,size:2+Math.random()*3}); } }
  function drawSparks(g){ const dt=1/FPS; g.save(); g.globalCompositeOperation='lighter';
    sparkLive.forEach(s=>{ s.age+=dt; s.x+=s.vx*dt; s.y+=s.vy*dt; s.vx*=0.98; s.vy=s.vy*0.98+80*dt; const p=1-s.age/s.life; if(p<=0) s.dead=true; drawStar(g,s.x,s.y,5,8*s.size*p,3*s.size*p,`rgba(255,255,255,${p})`); });
    for(let i=sparkLive.length-1;i>=0;i--){ if(sparkLive[i].dead) sparkLive.splice(i,1); } g.restore();
  }
  function drawStar(g,x,y,spikes,outerR,innerR,color){ g.save(); g.translate(x,y); g.beginPath(); let rot=Math.PI/2*3; let step=Math.PI/spikes;
    g.moveTo(0,-outerR); for(let i=0;i<spikes;i++){ g.lineTo(Math.cos(rot)*outerR,Math.sin(rot)*outerR); rot+=step; g.lineTo(Math.cos(rot)*innerR,Math.sin(rot)*innerR); rot+=step; }
    g.lineTo(0,-outerR); g.closePath(); g.fillStyle=color; g.fill(); g.restore(); }

  /* 三視圖 */
  function drawTriViews(){
    aCtx.clearRect(0,0,triA.width,triA.height); bCtx.clearRect(0,0,triB.width,triB.height); cCtx.clearRect(0,0,triC.width,triC.height);
    if(!state.scenes.length) return;
    const info=timeToScene(state.t); const sc=state.scenes[info.idx]; const a=assetById(sc.assetId); if(!a?.img) return;
    drawContain(aCtx, a.img, triA.width, triA.height);
    const k0=sc.kfs[0]||makeDefaultKF(), k1=sc.kfs[sc.kfs.length-1]||makeDefaultKF();
    drawCropRectOnOriginalPanel(aCtx, a, triA.width, triA.height, k0, '#18ffff', 'Start');
    drawCropRectOnOriginalPanel(aCtx, a, triA.width, triA.height, k1, '#ff3cac', 'End');
    const off=document.createElement('canvas'); off.width=canvas.width; off.height=canvas.height; const og=off.getContext('2d');
    const kCur=kfAt(sc, info.localT); drawScene(og, sc, kCur, 1.0, null);
    bCtx.drawImage(off, 0,0, off.width, off.height, 0,0, triB.width, triB.height);
    cCtx.drawImage(canvas, 0,0, canvas.width, canvas.height, 0,0, triC.width, triC.height);
  }
  function drawContain(g, img, W, H){ g.save(); g.fillStyle='#000'; g.fillRect(0,0,W,H); const ar=img.naturalWidth/img.naturalHeight, arP=W/H;
    let dw,dh,ox,oy; if(ar>arP){ dw=W; dh=dw/ar; ox=0; oy=(H-dh)/2; } else { dh=H; dw=dh*ar; ox=(W-dw)/2; oy=0; } g.drawImage(img, ox,oy,dw,dh); g.restore(); }
  function drawCropRectOnOriginalPanel(g, asset, W, H, k, color, tag){
    const ar=asset.w/asset.h, arP=W/H; let dw,dh,ox,oy; if(ar>arP){ dw=W; dh=dw/ar; ox=0; oy=(H-dh)/2; } else { dh=H; dw=dh*ar; ox=(W-dw)/2; oy=0; }
    const full = coverSize(asset.w, asset.h, canvas.width, canvas.height, k.s);
    const vw = canvas.width / full.dw * dw, vh = canvas.height / full.dh * dh;
    const maxX = Math.max(0,(dw - vw)/2), maxY = Math.max(0,(dh - vh)/2);
    const px = (k.tx / ((full.dw - canvas.width)/2 || 1)) * maxX;
    const py = (k.ty / ((full.dh - canvas.height)/2 || 1)) * maxY;
    const cx = ox + dw/2 + px, cy = oy + dh/2 + py; const x = clamp(cx - vw/2, ox, ox+dw-vw); const y=clamp(cy - vh/2, oy, oy+dh-vh);
    g.save(); g.strokeStyle=color; g.lineWidth=2; g.strokeRect(x,y,vw,vh); g.fillStyle=color; g.font='12px system-ui'; g.fillText(tag, x+4, y+14); g.restore();
  }
  function coverSize(iw,ih,W,H,scale=1){ const arI=iw/ih, arC=W/H; let dw,dh; if(arI>arC){ dh=H*scale; dw=dh*arI; } else { dw=W*scale; dh=dw/arI; } return {dw,dh}; }

  /* Inspector / 運鏡 */
  function updateInspector(){
    const idx=state.activeIdx, sc=state.scenes[idx]; if(!sc){ ui.clipInfo.textContent='未選取'; return; }
    const a=assetById(sc.assetId); ui.clipInfo.innerHTML = `<b>${idx+1}. ${a?.name||'素材'}</b>｜${sc.duration.toFixed(2)}s`;
    ui.transitionType.value=sc.trans.type; ui.transitionDur.value=sc.trans.dur;
    const {idx:i, localT} = timeToScene(state.t); if(i===idx){ const k=kfAt(sc, localT); ui.tx.value=k.tx; ui.ty.value=k.ty; ui.scale.value=k.s; ui.rot.value=k.r; ui.skx.value=k.skx; ui.sky.value=k.sky; ui.rotx.value=k.rotx; ui.roty.value=k.roty; ui.bright.value=k.filt.b; ui.contrast.value=k.filt.c; ui.saturate.value=k.filt.s; ui.blur.value=k.filt.blur; }
    ui.shakeEnable.checked=!!sc.fx.shake.on; ui.shakeAmp.value=sc.fx.shake.amp; ui.shakeFreq.value=sc.fx.shake.freq;
  }
  ui.transitionType.addEventListener('change', ()=>{ const sc=state.scenes[state.activeIdx]; if(!sc) return; sc.trans.type=ui.transitionType.value; renderTimeline(); });
  ui.transitionDur.addEventListener('input', ()=>{ const sc=state.scenes[state.activeIdx]; if(!sc) return; sc.trans.dur=Math.max(0, parseFloat(ui.transitionDur.value)||0); renderTimeline(); });
  ui.applyCine.addEventListener('click', ()=>{
    const sc=state.scenes[state.activeIdx]; if(!sc) return; const a=assetById(sc.assetId); if(!a) return;
    const move=ui.cineMove.value, amount=parseFloat(ui.cineAmount.value)||0; const shotS = scaleByShot(ui.shotScale.value); const angle=anglePreset(ui.shotAngle.value);
    const {startKF,endKF} = planMotionForScene(a,{W:canvas.width,H:canvas.height}, move, amount, shotS, angle);
    startKF.t=0; endKF.t=sc.duration; sc.kfs=[startKF,endKF]; draw(); renderTimeline();
  });
  function scaleByShot(code){ switch(code){ case 'ELS': return 1.00; case 'LS': return 1.05; case 'MLS': return 1.20; case 'MS': return 1.40; case 'MCU': return 1.70; case 'CU': return 2.20; case 'XCU': return 3.00; default: return 1.4; } }
  function anglePreset(code){ switch(code){ case 'high':return{rotx:+12,roty:0,rot:0}; case 'low':return{rotx:-12,roty:0,rot:0}; case 'top':return{rotx:+35,roty:0,rot:0}; case 'bottom':return{rotx:-35,roty:0,rot:0}; case 'dutch':return{rotx:0,roty:0,rot:+10}; case 'oblique':return{rotx:0,roty:+12,rot:0}; default:return{rotx:0,roty:0,rot:0}; } }
  function planMotionForScene(asset, canvasSize, move, amount, shotScale, angle){
    const W=canvasSize.W,H=canvasSize.H; const {dw,dh}=coverSize(asset.w,asset.h,W,H,shotScale);
    const maxX=Math.max(0,(dw-W)/2), maxY=Math.max(0,(dh-H)/2); const amt=clamp(amount,0,100)/100;
    const k0=makeDefaultKF(), k1=makeDefaultKF(); k0.s=k1.s=shotScale; k0.rotx=k1.rotx=angle.rotx; k0.roty=k1.roty=angle.roty; k0.r=k1.r=angle.rot;
    switch(move){
      case 'truckR': k0.tx=+amt*maxX; k1.tx=-amt*maxX; break;
      case 'truckL': k0.tx=-amt*maxX; k1.tx=+amt*maxX; break;
      case 'pedUp':  k0.ty=-amt*maxY; k1.ty=+amt*maxY; break;
      case 'pedDown':k0.ty=+amt*maxY; k1.ty=-amt*maxY; break;
      case 'zoomIn': k0.s=shotScale; k1.s=shotScale*(1+0.8*amt); break;
      case 'zoomOut':k0.s=shotScale*(1+0.6*amt); k1.s=shotScale; break;
      case 'panL':   k0.roty=+12*amt+angle.roty; k1.roty=-12*amt+angle.roty; break;
      case 'panR':   k0.roty=-12*amt+angle.roty; k1.roty=+12*amt+angle.roty; break;
      case 'tiltUp': k0.rotx=-10*amt+angle.rotx; k1.rotx=+10*amt+angle.rotx; break;
      case 'tiltDown':k0.rotx=+10*amt+angle.rotx; k1.rotx=-10*amt+angle.rotx; break;
      case 'orbitL': k0.roty=+10*amt+angle.roty; k1.roty=-10*amt+angle.roty; k0.tx=+amt*0.6*maxX; k1.tx=-amt*0.6*maxX; break;
      case 'orbitR': k0.roty=-10*amt+angle.roty; k1.roty=+10*amt+angle.roty; k0.tx=-amt*0.6*maxX; k1.tx=+amt*0.6*maxX; break;
    }
    return {startKF:k0,endKF:k1};
  }

  ;['tx','ty','scale','rot','skx','sky','rotx','roty','bright','contrast','saturate','blur'].forEach(id=>{
    const el=$('#'+id); el.addEventListener('input', ()=>{ const sc=state.scenes[state.activeIdx]; if(!sc) return; const {localT}=timeToScene(state.t); const k=kfAt(sc, localT);
      k.tx=+ui.tx.value||0; k.ty=+ui.ty.value||0; k.s=+ui.scale.value||1; k.r=+ui.rot.value||0; k.skx=+ui.skx.value||0; k.sky=+ui.sky.value||0; k.rotx=+ui.rotx.value||0; k.roty=+ui.roty.value||0; k.filt={b:+ui.bright.value||1,c:+ui.contrast.value||1,s:+ui.saturate.value||1,blur:+ui.blur.value||0};
      clampKFToBounds(k, assetById(sc.assetId), state.limitByMove?ui.cineMove.value:'none'); if(state.autoKey) writeKeyAt(sc, localT, k); draw(); });
  });
  ui.addKeyBtn.addEventListener('click', addKeyAtCurrent);
  ui.autoKey.addEventListener('change', ()=> state.autoKey = ui.autoKey.checked);
  function addKeyAtCurrent(){ const info=timeToScene(state.t); const sc=state.scenes[info.idx]; if(!sc) return; const k=currentInspectorKF(); k.filt={b:+ui.bright.value,c:+ui.contrast.value,s:+ui.saturate.value,blur:+ui.blur.value}; sc.kfs.push({t:clamp(info.localT,0,sc.duration), ...k}); renderKeybar(sc); }
  function currentInspectorKF(){ return { tx:+ui.tx.value||0, ty:+ui.ty.value||0, s:+ui.scale.value||1, r:+ui.rot.value||0, skx:+ui.skx.value||0, sky:+ui.sky.value||0, rotx:+ui.rotx.value||0, roty:+ui.roty.value||0, filt:{b:+ui.bright.value||1,c:+ui.contrast.value||1,s:+ui.saturate.value||1, blur:+ui.blur.value||0} }; }
  function renderKeybar(sc){ const kb=ui.keybar; kb.innerHTML=''; if(!sc) return; const total=sc.duration||1; sc.kfs.forEach(k=>{ const d=document.createElement('div'); d.className='key'; d.style.left=(k.t/total*100)+'%'; kb.append(d); }); }

  /* 取景限制 */
  function clampKFToBounds(k, asset, move='none'){
    const W=canvas.width, H=canvas.height; const {dw,dh}=coverSize(asset.w,asset.h,W,H,k.s);
    const maxX=Math.max(0,(dw-W)/2), maxY=Math.max(0,(dh-H)/2);
    k.tx = clamp(k.tx, -maxX, +maxX); k.ty = clamp(k.ty, -maxY, +maxY);
    if(move.startsWith('truck')) k.ty = 0;   // 鎖垂直
    if(move.startsWith('ped'))   k.tx = 0;   // 鎖水平
  }

  /* 字幕 */
  ui.srtInput.addEventListener('change', async (e)=>{ const f=e.target.files?.[0]; if(!f) return; const text=await f.text(); const cues=parseSRT(text); state.subtitles.push(...cues); renderSubtitles(); });
  ui.addSubtitle.addEventListener('click', ()=>{ state.subtitles.push({id:crypto.randomUUID(), start:clamp(state.t,0,projectTotal()), end:clamp(state.t+2,0,projectTotal()), text:'新的字幕'}); renderSubtitles(); });
  function parseSRT(s){ const lines=s.replace(/\r/g,'').split('\n'); const out=[]; let i=0; while(i<lines.length){ if(!lines[i].trim()){i++;continue;} const idx=lines[i++].trim(); if(!/^\d+$/.test(idx)) continue;
    const tl=lines[i++].trim(); const m=tl.match(/(\d+:\d+:\d+),(\d+)\s*-->\s*(\d+:\d+:\d+),(\d+)/); if(!m) continue;
    const start=h2s(m[1])+parseInt(m[2])/1000, end=h2s(m[3])+parseInt(m[4])/1000; let t=''; while(i<lines.length && lines[i].trim()!==''){ t+=(t?'\n':'')+lines[i++]; } out.push({id:crypto.randomUUID(), start, end, text:t}); i++; } return out; }
  function h2s(hms){ const [h,m,s]=hms.split(':').map(Number); return h*3600+m*60+s; }
  function renderSubtitles(){ const box=ui.subtitleList; box.innerHTML=''; state.subtitles.sort((a,b)=>a.start-b.start).forEach(sub=>{ const row=document.createElement('div'); row.className='asset'; row.style.gridTemplateColumns='90px 90px 1fr auto';
      const si=mkNum(sub.start,v=>sub.start=v); const ei=mkNum(sub.end,v=>sub.end=v); const ti=mkText(sub.text,v=>sub.text=v); const rm=mkBtn('刪除',()=>{ state.subtitles=state.subtitles.filter(x=>x!==sub); renderSubtitles(); });
      row.append(si,ei,ti,rm); box.append(row);
    });
    function mkNum(val,on){ const i=document.createElement('input'); i.type='number'; i.step='0.01'; i.value=val.toFixed(2); i.oninput=()=>on(parseFloat(i.value)||val); return i; }
    function mkText(val,on){ const i=document.createElement('input'); i.type='text'; i.value=val; i.oninput=()=>on(i.value); return i; }
    function mkBtn(t,fn){ const b=document.createElement('button'); b.className='btn small'; b.textContent=t; b.onclick=fn; return b; }
  }
  function drawSubtitles(g,t,W,H){ const act=state.subtitles.filter(s=>t>=s.start && t<=s.end); if(!act.length) return; const text=act[0].text; g.save(); g.font=Math.round(H*0.04)+'px "Noto Sans TC", system-ui'; g.textAlign='center'; g.textBaseline='alphabetic';
    const padX=Math.round(W*0.08), padY=Math.round(H*0.06), boxW=W-padX*2; const lines=wrapText(g,text,boxW*0.92), lineH=Math.round(H*0.055), totalH=lineH*lines.length + padY*0.3; const x=W/2,y=H-padY-totalH/4;
    g.save(); g.globalAlpha=0.55; g.fillStyle='#000'; const bw=Math.max(...lines.map(l=>g.measureText(l).width))+24; const bx=x-bw/2, by=y-lines.length*lineH-18; roundRect(g,bx,by,bw,totalH,10); g.fill(); g.restore();
    g.shadowColor='rgba(0,0,0,.9)'; g.shadowBlur=8; g.fillStyle='#fff'; lines.forEach((ln,i)=>g.fillText(ln,x,y-(lines.length-1-i)*lineH)); g.restore(); }
  function wrapText(g,text,maxWidth){ const raw=text.split('\n').flatMap(s=>s.split(/\\n/g)); const out=[]; raw.forEach(line=>{ let cur=''; for(const ch of line){ const w=g.measureText(cur+ch).width; if(w>maxWidth && cur!==''){ out.push(cur); cur=ch; } else cur+=ch; } if(cur) out.push(cur); }); return out; }
  function roundRect(g,x,y,w,h,r){ g.beginPath(); g.moveTo(x+r,y); g.arcTo(x+w,y,x+w,y+h,r); g.arcTo(x+w,y+h,x,y+h,r); g.arcTo(x,y+h,x,y,r); g.arcTo(x,y,x+w,y,r); g.closePath(); }

  /* TTS / 錄製 / 專案 */
  async function ttsFetchBlob({apiKey, model, voice, input, format='mp3'}){ const resp=await fetch('https://api.openai.com/v1/audio/speech',{method:'POST',headers:{'Authorization':`Bearer ${apiKey}`,'Content-Type':'application/json'},body:JSON.stringify({model,voice,input,format})}); if(!resp.ok){ const t=await resp.text().catch(_=>''); throw new Error(`TTS 失敗(${resp.status}) ${t}`); } const ab=await resp.arrayBuffer(); return new Blob([ab],{type:`audio/${format}`}); }
  async function blobToAudioBuffer(blob){ const ab=await blob.arrayBuffer(); return await audioCtx.decodeAudioData(ab); }
  $('#ttsGen').addEventListener('click', async ()=>{ if(!ui.apiKey.value){ alert('請先輸入 OpenAI API Key'); return; } await audioCtx.resume(); const text=$('#ttsText').value?.trim(); if(!text) return;
    $('#ttsGen').disabled=true; $('#ttsGen').textContent='生成中…'; try{ const blob=await ttsFetchBlob({apiKey:ui.apiKey.value, model:$('#ttsModel').value, voice:$('#ttsVoice').value, input:text, format:$('#ttsFormat').value}); const buf=await blobToAudioBuffer(blob); const at=$('#ttsAt').value?parseFloat($('#ttsAt').value):state.t; state.audioCues.push({id:crypto.randomUUID(), start:clamp(at,0,projectTotal()), buffer:buf, gain:1.0}); $('#ttsGen').textContent='完成！'; setTimeout(()=>$('#ttsGen').textContent='產生並加入時間軸',800); }catch(err){ alert('TTS 失敗：'+err.message); $('#ttsGen').textContent='重試'; } finally{ $('#ttsGen').disabled=false; } });
  $('#ttsPreview').addEventListener('click', async ()=>{ await audioCtx.resume(); const text=$('#ttsText').value?.trim(); if(!text) return; $('#ttsPreview').disabled=true; $('#ttsPreview').textContent='生成中…';
    try{ const blob=await ttsFetchBlob({apiKey:ui.apiKey.value, model:$('#ttsModel').value, voice:$('#ttsVoice').value, input:text, format:$('#ttsFormat').value}); const url=URL.createObjectURL(blob); const a=new Audio(url); a.play(); a.onended=()=>{ URL.revokeObjectURL(url); $('#ttsPreview').disabled=false; $('#ttsPreview').textContent='預聽'; }; }catch(err){ alert('TTS 預聽失敗：'+err.message); $('#ttsPreview').disabled=false; $('#ttsPreview').textContent='預聽'; }});
  ui.rememberKey.addEventListener('click', ()=>{ localStorage.setItem('OPENAI_KEY', ui.apiKey.value||''); alert('已記住（僅此瀏覽器）'); });

  let recorder=null, chunks=[];
  ui.recordBtn.addEventListener('click', async ()=>{ if(recorder){ recorder.stop(); return; } await audioCtx.resume(); state.t=0; draw(); renderPlayhead(); const stream=canvas.captureStream(FPS); mediaDest.stream.getAudioTracks().forEach(track=>stream.addTrack(track));
    recorder=new MediaRecorder(stream,{mimeType:'video/webm;codecs=vp9,opus'}); chunks=[]; recorder.ondataavailable=e=>{ if(e.data?.size) chunks.push(e.data); };
    recorder.onstop=()=>{ const blob=new Blob(chunks,{type:'video/webm'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`kinetic-stills-${Date.now()}.webm`; a.click(); setTimeout(()=>URL.revokeObjectURL(url),5000); recorder=null; ui.recordBtn.textContent='錄製 WebM'; };
    ui.recordBtn.textContent='錄製中…（再次點擊停止）'; state.playing=true; state.lastTick=now(); step(); recorder.start();
  });
  ui.saveBtn.addEventListener('click', ()=>{ const data={v:4, scenes:state.scenes, subtitles:state.subtitles, audioCues:state.audioCues.map(c=>({id:c.id,start:c.start,gain:c.gain})), assets:state.assets.map(a=>({id:a.id,name:a.name,hint:`請重新載入：${a.name}`}))};
    const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='project.kinetic.json'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),3000); });
  ui.loadBtn.addEventListener('click', ()=>{ const ip=document.createElement('input'); ip.type='file'; ip.accept='.json'; ip.onchange=async ()=>{ const f=ip.files?.[0]; if(!f) return; const data=JSON.parse(await f.text());
      state.scenes=data.scenes||[]; state.subtitles=data.subtitles||[]; state.audioCues=[]; state.activeIdx = state.scenes.length?0:-1; renderAssets(); renderTimeline(); refreshTotals(); renderSubtitles(); draw(); }; ip.click(); });
  ui.clearBtn.addEventListener('click', ()=>{ if(confirm('確定清空？這會移除所有素材、片段與字幕（不含本機檔案）')){ state.assets.forEach(a=>URL.revokeObjectURL(a.url)); Object.assign(state,{assets:[], scenes:[], subtitles:[], audioCues:[], t:0, activeIdx:-1}); renderAssets(); renderTimeline(); refreshTotals(); renderSubtitles(); draw(); } });

  function triggerAudioCues(){ state.audioCues.forEach(c=>{ if(!playedOnce.has(c.id) && state.t>=c.start){ const src=audioCtx.createBufferSource(); src.buffer=c.buffer; const g=audioCtx.createGain(); g.gain.value=c.gain; src.connect(g).connect(masterGain); src.start(0); playedOnce.add(c.id); src.onended=()=>{ if(state.loop) playedOnce.delete(c.id); }; } }); }
  const playedOnce=new Set();

  renderAssets(); renderTimeline(); refreshTotals(); renderSubtitles(); setViewButtons(); drawRuler(); draw();

  function mkBtn(t,fn){ const b=document.createElement('button'); b.className='btn small'; b.textContent=t; b.onclick=fn; return b; }
})();
</script>
</body>
</html>
